using System;
using System.Collections.Generic;
using System.Linq;
using System.Security.Authentication.ExtendedProtection;
using System.Text;
using System.Threading.Tasks;

namespace HW3
{
    //----------------------------------------
    // Bingo 類別的基本架構，請參考並完成它！
    //----------------------------------------
    class Bingo
    {
        int side;          // 每邊幾個數字，需要是奇數。
        int selected = 0;  // 記錄已經選了多少個號碼。
        int lines = 0;     // 目前湊足的連線數。

        int[] series = null;   // 儲存合理的數字範圍: 1 ~ side*side。
        int[,] numbers = null;   // 記錄每個Cell中的數字，1 ~ side*side
        int[,] marks = null;   // 0: not selected;  1: selected.

        // additional trackers to avoid double counting lines
        bool[] rowDone = null;
        bool[] colDone = null;
        bool diag1Done = false;
        bool diag2Done = false;

        public Bingo(int side = 5)
        {
            this.side = side;
            reset();
        }

        // Fisher-Yates Shuffle algorithm:
        public void shuffle()
        {
            Random rand = new Random();
            int n = series.Length;
            for (int i = n - 1; i > 0; i--)
            {
                int j = rand.Next(0, i + 1);
                int tmp = series[i];
                series[i] = series[j];
                series[j] = tmp;
            }
        }

        public void play()
        {
            reset();  // reset the values to start a new Bingo game

            bool playing = true;
            while (playing)
            {
                playing = go();
                if (!playing) break;

                if (lines >= side)
                {
                    show();
                    Console.WriteLine($"Bingo! You completed {lines} lines. Game over.");
                    break;
                }
            }
        }

        

        public bool go()
        {
            show();  // 顯示目前的Bingo表，方便使用者選擇接下來要劃記的位置與數字。

            Console.Write($"\ninput a number (1~{side * side}, or 0 to quit): ");
            string inp = Console.ReadLine();

            if (inp == null) return false;

            if (inp.Trim() == "0")
            {
                Console.WriteLine("Quit Bingo game!");
                return false;
            }

            int k;
            if (!int.TryParse(inp, out k))
            {
                Console.WriteLine("輸入格式錯誤!");
                return true;
            }

            if (k < 1 || side * side < k)
            {
                Console.WriteLine("數字超出範圍!");
            }
            else
            {
                markCell(k);
                cpuMarkcell();

            }
            return true;  // true: 繼續玩; false: 結束或跳出程式。
        }

        public bool chkcell(int k) // check if cell k is already marked
        {
            for (int r = 0; r < numbers.GetLength(0); r++)
            {
                for (int c = 0; c < numbers.GetLength(1); c++)
                {
                    if (numbers[r, c] == k)
                    {
                        if (marks[r, c] == 1)
                        {
                            return true;
                        }
                        else
                        {
                            return false;
                        }
                    }
                }
            }
            return false;

        }

        public void cpuMarkcell() //computer randomly marks a cell
        {
            Random rand = new Random();
            int k;
            do
            {
                k = rand.Next(1, side * side + 1);
            } while (chkcell(k));
            Console.WriteLine($"Computer marks number: {k}");
            markCell(k);
        }
        public void markCell(int k)
        {
            // find k in numbers
            for (int r = 0; r < numbers.GetLength(0); r++)
            {
                for (int c = 0; c < numbers.GetLength(1); c++)
                {
                    if (numbers[r, c] == k)
                    {
                        if (marks[r, c] == 1)
                        {
                            Console.WriteLine("此數字已被劃記過!");
                            return;
                        }
                        marks[r, c] = 1;
                        selected++;

                        bool anyNew = chkLine(r, c);
                        if (anyNew)
                        {
                            Console.WriteLine($"Good! You formed a new line. Total lines: {lines}");
                        }
                        return;
                    }
                }
            }
            Console.WriteLine("指定的數字未找到在Bingo表中!");
        }

        public void show()
        {
            // 顯示整格表格，被劃記的部分則以符號 @ 表示。
            int n = side;
            for (int i = 0; i < n; i++) Console.Write("+----");
            Console.WriteLine("+");

            for (int r = 0; r < n; r++)
            {
                for (int c = 0; c < n; c++)
                {
                    if (marks[r, c] == 1)
                    {
                        Console.Write("|  @ ");
                    }
                    else
                    {
                        int v = numbers[r, c];
                        if (v < 10)
                            Console.Write($"|  {v} ");
                        else if (v < 100)
                            Console.Write($"| {v} ");
                        else
                            Console.Write($"|{v}");
                    }
                }
                Console.WriteLine("|");

                for (int i = 0; i < n; i++) Console.Write("+----");
                Console.WriteLine("+");
            }
            Console.WriteLine($"Selected: {selected}, Lines: {lines}");
        }

        public bool chkLine(int r, int c)
        {
            bool foundNew = false;
            // check row r
            bool full = true;
            for (int cc = 0; cc < side; cc++)
            {
                if (marks[r, cc] == 0) { full = false; break; }
            }
            if (full && !rowDone[r])
            {
                rowDone[r] = true;
                lines++;
                foundNew = true;
            }

            // check column c
            full = true;
            for (int rr = 0; rr < side; rr++)
            {
                if (marks[rr, c] == 0) { full = false; break; }
            }
            if (full && !colDone[c])
            {
                colDone[c] = true;
                lines++;
                foundNew = true;
            }

            // check main diagonal (r==c)
            if (r == c)
            {
                full = true;
                for (int i = 0; i < side; i++)
                {
                    if (marks[i, i] == 0) { full = false; break; }
                }
                if (full && !diag1Done)
                {
                    diag1Done = true;
                    lines++;
                    foundNew = true;
                }
            }

            // check anti-diagonal (r + c == side-1)
            if (r + c == side - 1)
            {
                full = true;
                for (int i = 0; i < side; i++)
                {
                    if (marks[i, side - 1 - i] == 0) { full = false; break; }
                }
                if (full && !diag2Done)
                {
                    diag2Done = true;
                    lines++;
                    foundNew = true;
                }
            }

            return foundNew;
        }


        public void reset()
        {
            selected = 0;
            lines = 0;

            if (series == null || series.Length != side * side)
            {
                series = new int[side * side];
                for (int i = 0; i < series.Length; i++) series[i] = i + 1;
            }

            if (numbers == null || numbers.GetLength(0) != side || numbers.GetLength(1) != side)
            {
                numbers = new int[side, side];
                marks = new int[side, side];
                rowDone = new bool[side];
                colDone = new bool[side];
                diag1Done = diag2Done = false;
            }

            // shuffle series and fill numbers
            shuffle();  // 將數列進行洗牌。

            int index = 0;
            for (int r = 0; r < numbers.GetLength(0); r++)
            {
                for (int c = 0; c < numbers.GetLength(1); c++)
                {
                    numbers[r, c] = series[index++];
                    marks[r, c] = 0;
                }
            }

            // reset trackers
            for (int i = 0; i < side; i++) { rowDone[i] = false; colDone[i] = false; }
            diag1Done = diag2Done = false;
        }

    }
}
